---
import Container from "../../shared/Container.astro";
import type { HIWPhase } from "../../../interface/HIWPhase";
import { Image } from "astro:assets";
import type { ImageInterface } from "../../../interface/Image";

export interface Props {
  hiwPhase: HIWPhase[];
  images: ImageInterface[];
}

const { hiwPhase, images } = Astro.props;

let imagePosition = -1;
---

<section id="how-it-work-steps" class="hidden lg:block">
  <Container className="flex flex-col gap-20 z-10 pb-40">
    <div class="grid grid-cols-1 md:grid-cols-2 mt-10">
      <div>
        <div>
          <span
            class="rounded-full border px-4 py-2 text-sm text-primary font-medium"
          >
            Step-by-step
          </span>
          <div class="text-4xl font-semibold mt-5">
            Like building a new house, we prepare carefully for every steps.
          </div>
        </div>
        <div class="flex flex-col gap-7 mt-10">
          {
            hiwPhase.map((phase) => (
              <div class="flex flex-col">
                <h3 class="text-lg font-semibold">{phase.title}</h3>
                <div>
                  {phase.steps.map((step, stepIndex) => {
                    imagePosition += 1;
                    return (
                      <div
                        class="step flex flex-col px-6 rounded-lg transition-colors duration-500"
                        data-image-position={imagePosition}
                      >
                        <div class="flex flex-col gap-4 py-6 border-b">
                          <div class="flex flex-row gap-5 justify-start items-center">
                            <span class="text-md font-normal w-4 text-primary">{`0${
                              stepIndex + 1
                            }`}</span>
                            <h4 class="title text-2xl font-medium">
                              {step.title}
                            </h4>
                          </div>
                          <div class="">{step.description}</div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            ))
          }
        </div>
      </div>
      <div>
        <div class="top-0 sticky self-start">
          <div id="child" class="flex justify-end">
            {
              images.map((image, index) => (
                <Image
                  class={`step-image transition-all duration-500 object-contain rounded-lg w-[450px] h-[450px] ${
                    index === 0 ? "opacity-100" : "opacity-0 ml-[-450px]"
                  }`}
                  data-position={index}
                  src={image}
                  alt=""
                  loading="lazy"
                />
              ))
            }
          </div>
        </div>
      </div>
    </div>
  </Container>
</section>

<style>
  .step.bg-slate-200 .title {
    --tw-text-opacity: 1;
    color: rgb(119 90 252 / var(--tw-text-opacity));
  }
</style>

<script>
  const config = {
    root: document,
    rootMargin: "-45% 0px -55%",
  };
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry, index) => {
        entry.target.classList.remove("bg-slate-200");
        if (entry.isIntersecting) {
          entry.target.classList.add("bg-slate-200");

          const imageEls = document.querySelectorAll(`.step-image`);

          imageEls.forEach((imageEl) => {
            imageEl.classList.remove("opacity-100", "opacity-0");
            imageEl.classList.add("opacity-0");
          });

          const imagePosition = entry.target.getAttribute(
            "data-image-position"
          );

          const imageChose = document.querySelector(
            `.step-image[data-position="${imagePosition}"]`
          );
          imageChose?.classList.remove("opacity-0");
          imageChose?.classList.add("opacity-100");
        } else {
        }
      });
    },
    { ...config }
  );

  const targetElements = document.querySelectorAll(".step");
  targetElements.forEach((element) => {
    observer.observe(element);
  });

  // const stepEl = Array.from(document.getElementsByClassName("step_element"));
  // stepEl.forEach((element) => {
  //   element.addEventListener("mouseover", () => {
  //     const dataPhase = element.getAttribute("data-phase");
  //     const dataStep = element.getAttribute("data-step");
  //     const imageChose = document.querySelector(
  //       `[data-phase="image_phase_${dataPhase}"][data-step="image_step_${dataStep}"]`
  //     );

  //     if (imageChose.classList.contains("block")) return;

  //     const imageEls = document.querySelectorAll(
  //       `[data-phase="image_phase_${dataPhase}"][data-step]`
  //     );

  //     // Loop through the NodeList and do something with each element
  //     imageEls.forEach((imageEl) => {
  //       imageEl.classList.remove("block", "opacity-100", "hidden", "opacity-0");
  //       imageEl.classList.add("hidden", "opacity-0");
  //     });

  //     imageChose.classList.remove("hidden", "opacity-0");
  //     imageChose.classList.add("block", "opacity-100");
  //   });
  // });
</script>
